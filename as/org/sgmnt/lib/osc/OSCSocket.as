/** * * Copyright (c) 2010 - 2012, http://sgmnt.org/ *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * */package org.sgmnt.lib.osc {        import flash.events.DatagramSocketDataEvent;    import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.IOErrorEvent;    import flash.events.TimerEvent;    import flash.net.DatagramSocket;    import flash.net.NetworkInfo;    import flash.net.NetworkInterface;    import flash.system.System;    import flash.utils.ByteArray;    import flash.utils.Dictionary;    import flash.utils.Timer;
        /**     * DatagramSocket を利用し,OSCを簡単に扱えるようにしたクラスです.     * @author    sgmnt.org     * @version   0.1.1     * @example   <listing version="3.0">     *                var sock:OSCSocket = new OSCSocket();     *                sock.addEventListener("/message/1", _onMessage);     *                sock.bind( 10000, "127.0.0.1" );     *                sock.receive();     *                // Event Listener.     *                function _onMessage(e:OSCSocketEvent):void{     *                    trace( e.address, e.args );     *                }     *            </listing>     */    public class OSCSocket extends EventDispatcher {                //------- MEMBER ----------------------------------------------------------------------- */        private var _socket:DatagramSocket;                private var _tmpByteArray;                private var _addressTree:Array;        private var _patternCache:Array;        private var _eventObjectCache:Array;                private var _objectDictionary:Array;                //------- PUBLIC ----------------------------------------------------------------------- */                /**         * コンストラクタ.         */        public function OSCSocket() {                        super();                        _tmpByteArray = new ByteArray();                        _addressTree = new Array();            _patternCache = new Array();            _eventObjectCache = new Array();                        _socket = new DatagramSocket();            _socket.addEventListener( DatagramSocketDataEvent.DATA, _onData );            _socket.addEventListener( IOErrorEvent.IO_ERROR, _onIOError );            _socket.addEventListener( Event.CLOSE, _onClose );                        _objectDictionary = new Array();                    }                /** このソケットオブジェクトが現在ローカルのアドレスとポートにバインドされているかどうかを示します。 */        public function get bound():Boolean { return _socket.bound; }                /** このソケットオブジェクトが現在リモートのアドレスとポートにバインドされているかどうかを示します。 */        public function get connected():Boolean { return _socket.connected; }                /** ローカルマシン上でこのソケットがバインドされている IP アドレス。 */        public function get localAddress():String { return _socket.localAddress; }                /** ローカルマシン上でこのソケットがバインドされているポート。 */        public function get localPort():int { return _socket.localPort; }                /** このソケットが接続されているリモートマシンの IP アドレス。  */        public function get remoteAddress():String { return _socket.remoteAddress; }                /** このソケットが接続されているリモートマシンのポート。 */        public function get remotePort():int { return _socket.remotePort; }                /**         * 指定されたローカルのアドレスおよびポートにこのソケットをバインドします。         * @param    localPort         * @param    localAddress         */        public function bind( localPort:int = 0, localAddress:String = "0.0.0.0" ):void {            trace("OSCSocket.bind [" + localAddress + ":" + localPort + "]");            _socket.bind( localPort, localAddress );        }                /**         * 実行中のマシンに割り当てられてるローカルのアドレスをにこのソケットをバインドします。         * @param    localPort         */        /*        public function bindLocal( localPort:int = 0 ):void{            var ifs:Vector.<NetworkInterface> = NetworkInfo.networkInfo.findInterfaces();            var addr:String = ifs[1].addresses[0].address;            _socket.bind( localPort, addr );        }        */                /**         * 指定されたリモートアドレスおよびポートにソケットを接続します。         * @param    remoteAddress         * @param    remotePort         */        public function connect( remoteAddress:String, remotePort:int ):void {            trace("connectiong... [address : " + remoteAddress + ", port : " + remotePort + "]");            _socket.connect( remoteAddress, remotePort );        }                /**         * この OSCSocket オブジェクトが、バインドされている IP アドレスおよび         * ポートで着信パケットを受信できるようにします。         */        public function receive():void{            _socket.receive();        }                /**         * OSCメッセージを送信します.         * @param    oscMessage    送信する OSC 文字列.         * @param    address        送信先アドレス.         * @param    port        接続先ポート.         */        public function send( packet:OSCPacket, address:String, port:int ):void {            var ba:ByteArray = packet.bytes;            _socket.send( ba, 0, ba.length, address, port );        }                /**         * ソケットを閉じます。         */        public function close():void {            if ( !connected ) return;            try{ _socket.close(); }catch(e){}        }                /**         * OSC メッセージに対するリスナ関数を定義します.         * @param    type    リスナ関数を指定するメッセージを指定します. ex) /a/b/c         *                     また、OSC の仕様に則ったアドレス指定に対応しています.         *                     例えば, /a/b/* と記述すると /a/b/任意の文字 などを一括してとる事が出来ます.         */        override public function addEventListener( type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false ):void{            // 管理テーブルに追加.            if( type.indexOf("/") == 0 && !hasEventListener(type) ){                var t:String = type + "$";                var address:Array = t.substring( 1, t.length ).split("/");                //trace(" ");                //trace("create OSC address tree : " + type);                //trace("-----------------------------------------------------");                _createAddress( _addressTree, address );                //trace( _dump( _addressTree, 0 ) );                //trace(" ");            }            super.addEventListener( type, listener, useCapture, priority, useWeakReference );        }                /**         * OSC メッセージに対するリスナ関数を削除します.         * @param    type    リスナ関数を指定したメッセージを指定します.         */        override public function removeEventListener( type:String,listener:Function,useCapture:Boolean = false ):void{            super.removeEventListener( type, listener, useCapture );            // 管理テーブルから削除.            if( type.indexOf("/") == 0 && !hasEventListener(type) ){                var t:String = type + "$";                var address:Array = t.substring( 1, t.length ).split("/");                //trace(" ");                //trace("remove OSC address tree : " + type);                //trace("-----------------------------------------------------");                _removeAddress( _addressTree, address );                //trace( _dump( _addressTree, 0 ) );                //trace(" ");            }        }                //------- PRIVATE ---------------------------------------------------------------------- */                // --- event listeners. ---                /**         * データの 8byte を調べ, bundle かを判断し処理を切り替える.         * @param    e         */        private function _onData(e:DatagramSocketDataEvent):void {            var bytes:ByteArray = e.data;            if ( bytes.readUTFBytes(8) == "#bundle" ) {                _createBundle( bytes, e.srcAddress, e.srcPort );            }else {                _execute( _createDispatchFunction( bytes, e.srcAddress, e.srcPort ) );            }        }                /**         * Bundle の処理を実行する.         * @param    bytes         * @param    srcAddress         * @param    srcPort         */        private function _createBundle( bytes:ByteArray, srcAddress:String, srcPort:int ):void {                        //trace("#bundle");                        var sec:int, millisec:int;            var time:Number;            var delay:Number;            var len:int            var tmp:ByteArray;            var list:Array;                        // Create Time-Tag.                        bytes.position = 8;            sec = bytes.readInt();                        bytes.position = 12;            millisec += bytes.readInt();                        time = ( sec * 1000 ) + ( millisec / 1000 );                        /*            trace("- sec      : " + sec);            trace("- millisec : " + millisec);            trace("- time     : " + time);            trace("- delay    : " + delay);            */                        delay = time - new Date().time;                        if( delay < 0 ){                                // Create packet bundle.                                bytes.position = 16;                                while( bytes.position < bytes.length ){                                        len = bytes.readInt();                                        _tmpByteArray = new ByteArray();                    _tmpByteArray.writeBytes( bytes, bytes.position, len );                    _tmpByteArray.position = 0;                                        if ( _tmpByteArray.readUTFBytes(8) == "#bundle" ) {                        _createBundle( _tmpByteArray, srcAddress, srcPort );                    }else {                        _execute( _createDispatchFunction( _tmpByteArray, srcAddress, srcPort ) );                    }                                        bytes.position += len;                                    }                            }else{                                // Create packet bundle.                                bytes.position = 16;                                while( bytes.position < bytes.length ){                                        len = bytes.readInt();                                        _tmpByteArray = new ByteArray();                    _tmpByteArray.writeBytes( bytes, bytes.position, len );                    _tmpByteArray.position = 0;                                        if ( _tmpByteArray.readUTFBytes(8) == "#bundle" ) {                        _createBundle( _tmpByteArray, srcAddress, srcPort );                    }else {                        if( !list ) list = [];                        list.push( _createDispatchFunction( _tmpByteArray, srcAddress, srcPort ) );                    }                                        bytes.position += len;                                    }                                if( list && 0 < list.length ){                    var timer:Timer = new Timer( delay, 1 );                    timer.addEventListener(TimerEvent.TIMER_COMPLETE, function(e) {                        while(list.length) _execute( list.shift() );                    });                    timer.start();                }                            }                    }                /**         * dispatchEvent を発生させる関数に必要な値を生成し,その値にアクセスするための文字列を返します.         * 値は _objectDictionary に格納されます.         * @param    bytes         * @param    srcAddress         * @param    srcPort         * @return         */        private function _createDispatchFunction( bytes:ByteArray, srcAddress:String, srcPort:int ):String{                        var key:String, p:int, offset:int, type:String,                address:String, types:String, values:Array;                        key = new Date().time + "_" + Math.random();                        bytes.position = 0;                        // Read Address.                        offset = 3;            while ( bytes[offset] != 0 && offset + 4 < bytes.length ) offset += 4;            address = bytes.readUTFBytes( offset+1 );                        // Read Types.                        p = bytes.position;            offset = 3;            while ( bytes[p + offset] != 0 && p + offset + 4 < bytes.length ) offset += 4;            types = bytes.readUTFBytes( offset+1 );                        // Read Values.                        values = [];            for ( var i:int = 0, len:int = types.length - 1; i < len; i++ ) {                type = types.charAt(i + 1).toLowerCase();                if ( type === "f" ) {                    values[i] = bytes.readFloat();                }else if( type === "i" ){                    values[i] = bytes.readInt();                }else if( type === "d" ){                    values[i] = bytes.readDouble();                }else if( type === "b" ){                    values[i] = bytes.readObject();                    bytes.position += 4 - bytes.position % 4;                }else if ( type === "s" ) {                    p = bytes.position;                    offset = 3;                    while ( bytes[p + offset] != 0 && p + offset + 4 < bytes.length ) offset += 4;                    values[i] = bytes.readUTFBytes( offset+1 );                }            }                        // Create dispatch event.                        _objectDictionary[key] = {                "srcAddress" : srcAddress,                "srcPort"    : srcPort,                "address"    : address,                "values"     : values            }                        return key;                    }                private function _execute(key:String):void{                        var obj:Object = _objectDictionary[key];                        if( obj != null ){                                var evt:OSCSocketEvent = new OSCSocketEvent( OSCSocketEvent.DATA, obj.srcAddress, obj.srcPort, obj.address, obj.values );                                dispatchEvent( evt );                                _dispatch(                    obj.srcAddress,                    obj.srcPort,                    obj.address.substring( 1, obj.address.length ).split("/"),                    obj.values,                    _addressTree                );                            }                        obj.srcAddress = null;            obj.srcPort    = null;            obj.address    = null;            obj.values     = null;                        obj = null;                        _objectDictionary[key] = null;            delete _objectDictionary[key];                    }                private function _onClose(e:Event):void {            trace(e);            dispatchEvent( new OSCSocketEvent( OSCSocketEvent.CLOSE ) );        }                private function _onIOError(e:IOErrorEvent):void {            trace(e);            dispatchEvent( new OSCSocketEvent( OSCSocketEvent.ERROR ) );        }                // --- private method. ---                /** addEventLisnter で追加された OSC アドレス空間との整合性を調べ再起的に dispatchEvent する. */        private function _dispatch( srcAddress:String, srcPort:int, address:Array, values:Array, node:Array, index:int = 0, typeStr:String = "" ):void{                        if( address.length == index ){                                // 過去に一度も dispatch した事がないイベントの場合は、イベントオブジェクトを生成する                if( !_eventObjectCache[typeStr] ){                    _eventObjectCache[typeStr] = new OSCSocketEvent( typeStr.replace("$","") );                }                                _eventObjectCache[typeStr]._setSrcState( srcAddress, srcPort );                                dispatchEvent( _eventObjectCache[typeStr]._setOSCMessage( "/"+address.join("/"), values ) );                                return;                            }else{                                for( var key:String in node ){                                        if ( !_patternCache[key] ) {                        _patternCache[key] = new RegExp(                            key.replace(/\*/g,"[^\/]+").replace(/\?/g,".")                               .replace(/{(.+?)}/g,"($1)").replace(/,/g,"|")                               .replace(/\[!/g,"^") + "$"                        );                    }                                        if( address[index].match( _patternCache[key] ) != null ){                        _dispatch( srcAddress, srcPort, address, values, node[key], index+1, typeStr+"/"+key );                    }                                    }                            }                    }                /** addEventLisnter で追加された OSC アドレス空間を再起的に生成する. */        private function _createAddress( list:Array, address:Array ){                        if( address.length == 0 ){                return;            }                        var part:String = address.shift();                        if( !list[part] ){                list[part] = new Array();            }                        _createAddress( list[part], address );                    }                /** addEventLisnter で追加された OSC アドレス空間を再起的に削除する. */        private function _removeAddress( list:Array, address:Array, route:Array = null, key:* = null ){                        var part:String = address.shift(), k:String, len:int = 0;                        // --- check remove target.            for( k in list ) len++;            if( !route || 1 < len ){                route = list;                key   = part;            }                        // --- check and remove.            if( !list[part] ){                delete route[key];            }else if( address.length == 0 ){                len = 0;                for( k in list[part] ) len++;                if( len == 0 ) delete route[key];            }else{                _removeAddress( list[part], address, route, key );            }                    }                /** listener登録されているアドレスツリーをダンプする. */        private function _dump( list:Array, tabs:int = 0 ):String{            var tab:String = "";            var i:int = tabs;            while( i-- ) tab += " ";            var str:Array = new Array();            for( var key:String in list ){                str.push( tab + key + "\n" + _dump(list[key],tabs+1) );            }            return str.join("\n");        }            }}