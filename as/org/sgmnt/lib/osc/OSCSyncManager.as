/** * * Copyright (c) 2010 - 2012, http://sgmnt.org/ *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * */package org.sgmnt.lib.osc {        import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.TimerEvent;    import flash.net.InterfaceAddress;    import flash.net.NetworkInfo;    import flash.net.NetworkInterface;    import flash.utils.Dictionary;    import flash.utils.Timer;        /**     * .     * Singleton Class.     * @author  sgmnt.org     * @version 0.1     */    public class OSCSyncManager extends EventDispatcher{                //------- CONSTS ----------------------------------------------------------------------- */		        //------- MEMBER ----------------------------------------------------------------------- */                /** Singleton Instance. */        static private var _instance:OSCSyncManager;        		private var _enabled:Boolean;				private var _socket:OSCSocket;				private var _localAddress:String;		private var _syncPort:int;		private var _useBroadcast:Boolean;		private var _broadcastPort:int;				private var _basetime:Number;		private var _basetimeTimer:Timer;				private var _groups:Dictionary;		private var _life:Number;				private var _isHost:Dictionary;        private var _createGroupTimerDictionary:Dictionary;				//------- PUBLIC ----------------------------------------------------------------------- */                /**         * Private Constructor.         */        public function OSCSyncManager( pvtClass:PrivateClass ) {                        super();						_enabled       = false;						_groups = new Dictionary();			_life   = 100000.0;						_isHost = new Dictionary();			_createGroupTimerDictionary = new Dictionary();			        }		        /**         * Get Singleton Instance.         * @return         */        static public function getInstance():OSCSyncManager{            if( _instance == null ){                _instance = new OSCSyncManager( new PrivateClass() );            }            return _instance;        }        		/**		 * 初期化処理です.必ず同期を開始する前に、始めに一回実行してください.		 * broadcast の方法などの Manager の基本的な挙動を設定します.		 * @param localAddress  自分のマシンのアドレス.		 * @param syncPort      同期処理を受信するポート.		 * @param broadcastPort ブロードキャストを通知するポート. 未指定の場合 ブロードキャストはしない.		 */		public function initialize( configure:OSCSyncManagerConfigure ):void{						// --- Setup Local Address. ---						_localAddress  = configure.localAddress;			_syncPort      = configure.syncPort;			_useBroadcast  = true;			_broadcastPort = 57578;						// --- Create OSCSocket. ---						_socket = new OSCSocket();			_socket.addEventListener( "/basetime"      , _onBasetimeMessageReceived     );			_socket.addEventListener( "/group/create"  , _onGroupCreateMessageReceived  );			_socket.addEventListener( "/group/destroy" , _onGroupDestoryMessageReceived );			_socket.addEventListener( OSCSocketEvent.CLOSE, _onSocketClose );			_socket.addEventListener( OSCSocketEvent.ERROR, _onSocketError );			_socket.bind( _syncPort, "0.0.0.0" );			_socket.receive();						// --- Setup Basetime. ---						_basetime = new Date().time;			_basetimeTimer = new Timer( 10000 );			_basetimeTimer.addEventListener( TimerEvent.TIMER, _onBasetimeUpdateTimer );			_basetimeTimer.start();						// --- Host ---					}				public function enable():void{			if( _enabled ) return;			_enabled = true;			dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.ENABLED ) );		}				public function disable():void{			if( !_enabled ) return;			_enabled = false;			dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.DISABLED ) );		}				// --- Override EventDispatcher Interfaces. ---				/**		 * 		 * @param type		 * @param listener		 * @param useCapture		 * @param priority		 * @param useWeakReference		 */		override public function addEventListener( type:String, listener:Function,												   useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false ):void{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :				case OSCSyncManagerEvent.GROUP_CREATED :					super.addEventListener( type, listener, useCapture, priority, useWeakReference );					break;				default :					_socket.addEventListener( type, listener, useCapture, priority, useWeakReference );			}		}				/**		 * 		 * @param type		 * @param listener		 * @param useCapture		 * 		 */		override public function removeEventListener( type:String, listener:Function, useCapture:Boolean = false ):void{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :				case OSCSyncManagerEvent.GROUP_CREATED :					super.removeEventListener( type, listener, useCapture );					break;				default :					_socket.removeEventListener( type, listener, useCapture );			}		}				/**		 * 		 * @param type		 * @return 		 */		override public function hasEventListener( type:String ):Boolean{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :				case OSCSyncManagerEvent.GROUP_CREATED :					return super.hasEventListener( type );					break;				default :					return _socket.hasEventListener( type );			}		}				/** 同期の基点なる時間を取得します. */				public function get basetime():Number{ return _basetime; }				/**		 * 指定した名称のグループにいくつのクライアントが存在するかを取得します.		 * @param name		 * @return 		 */		public function numGroupMember(name:String):int{			return _groups[name] ? _groups[name].length : 0;		}				/**		 * 指定した OSCMessage をブロードキャストします.		 * @param oscMessage OSCMessage アドレス.		 */		public function broadcast( oscMessage:OSCMessage ):void{			if( _useBroadcast ){				// Broadcast を別のアプリケーションに委譲する.				_socket.send( oscMessage, "127.0.0.1", _broadcastPort );			}else{							}		}		        /** 指定したグループに対して自分がホストであるか否か. */        public function isHost( group:String ):Boolean{ return _isHost[group] || false; }                // --- Control.                /**         * grouping の設定をサーバに要請します.         * 実際の要請処理は Timer で一定時間ごとに行われます.         * @param group グループ名.         */        public function createGroup( process:OSCSyncProcess ):void{						// TODO 1 Group の入れ物を作る.			// TODO 2 メッセージを受信し、登録していなければ実行する.			// TODO 3 登録されたタイミングで待ち時間を更新する.			// TODO 4 待ち時間が終了したらグループが制作作成されたことを伝え activate する.						var groupName:String = process.name;						if( _groups[groupName] == null ){				trace("TODO 1 Group の入れ物を作る.");				var group:Group = new Group(groupName);				group.addEventListener( Event.CLEAR, _onGroupActivate );				_groups[groupName] = group;			}			            if( _createGroupTimerDictionary[groupName] == null ){                                var msg:OSCMessage = new OSCMessage();                    msg.address = "/group/create";                    msg.addArgument( "s", groupName );                broadcast( msg );                                var timer:Timer = new Timer( 1000 );                    timer.addEventListener( TimerEvent.TIMER, function(e:TimerEvent):void{ broadcast( msg ); });                    timer.start();                _createGroupTimerDictionary[process.name] = timer;                            }                    }				/**		 * onGroupActivate.		 * @param event		 */		private function _onGroupActivate(event:Event):void{			trace("_onGroupActivate");			var group:Group = Group( event.target );			var evt:OSCSyncManagerEvent = new OSCSyncManagerEvent( OSCSyncManagerEvent.GROUP_CREATED );				evt._groupName = group.name;			dispatchEvent( evt );		}				/**		 * グループ生成のメッセージが来た際の処理.		 * 生成を確認したグループは通知の頻度を遅くする.		 * @param event		 */		private function _onGroupCreateMessageReceived(event:OSCSocketEvent):void{						var groupName:String = event.args[0];			var group:Group = _groups[groupName];						group.add( event.srcAddress );						_isHost[groupName] = ( event.srcAddress == _localAddress );						var timer:Timer = _createGroupTimerDictionary[groupName];			if( timer != null ){				timer.delay = Math.floor( _life * 0.4649 );				timer.reset();				timer.start();			}					}		        /**         * grouping の破棄をサーバに要請します.         * @param group グループ名.         */        public function destroyGroup( process:OSCSyncProcess ):void{            			var group:String = process.name;			            var timer:Timer = _createGroupTimerDictionary[group];            if( timer != null ){                timer.stop();                _createGroupTimerDictionary[group] = null;                delete _createGroupTimerDictionary[group];            }                        var msg:OSCMessage = new OSCMessage();            	msg.address = "/group/destroy";            	msg.addArgument("s",group);            broadcast( msg );                    }				/**		 * グループ生成のメッセージが来た際の処理.		 * 生成を確認したグループは通知の頻度を遅くする.		 * @param event		 */		private function _onGroupDestoryMessageReceived(event:OSCSocketEvent):void{						var group:String = event.args[0];						var timer:Timer = _createGroupTimerDictionary[group];			if( timer != null ){				timer.delay = Math.floor( _life * 0.4649 );				timer.reset();				timer.start();			}						var id:String = group + "::" + event.srcAddress;						var evt:OSCSyncManagerEvent = new OSCSyncManagerEvent( OSCSyncManagerEvent.GROUP_CREATED );			evt._groupName = group;			dispatchEvent( evt );					}				/**		 * OSCSocket の接続を切断します.		 */				public function close():void{			_socket.close();		}		        //------- PRIVATE ----------------------------------------------------------------------- */				// ===============================================================		// === basetime の設定				/**		 * 自分の basetime を通知し、他のマシンとの整合性を取る.		 * @param event		 */		private function _onBasetimeUpdateTimer(event:TimerEvent):void{			broadcast( new OSCMessage("/basetime ,f "+basetime) );		}				/**		 * 送られてきた basetime と自分のベースタイムを比べ、より早いベースタイムであった場合そちらにあわせる.		 * @param event		 */		private function _onBasetimeMessageReceived(event:OSCSocketEvent):void{			var time:Number = Number( event.args[0] );			trace("_onBasetimeMessageReceived",time);			if( time < _basetime ){				_basetime = time;			}else if( _basetime < time ){				// 自分よりも遅い時刻が送られてきた場合、自分の時間を通知しかえす.				broadcast( new OSCMessage("/basetime, f "+basetime) );			}		}				/**		 * ホストメッセージを受信した際の処理.		 * @param event		 */		private function _onGroupHost(event:OSCSocketEvent):void{			_isHost[event.args[0]] = ( event.args[1] == 1 );		}																        /**         * OSCSocket の接続が閉じられた際に実行されます.         * @param event         */        private function _onSocketClose(event:Event):void{            dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.SOCKET_ERROR ) );        }                /**         * OSCSocket の接続でエラーが発生した際に実行されます.         * エラー発生の旨を通知します.         * @param event         */        private function _onSocketError(event:Event):void{            dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.SOCKET_ERROR ) );        }		        //------- PROTECTED ---------------------------------------------------------------------- */                //------- INTERNAL ----------------------------------------------------------------------- */        	}    }import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.TimerEvent;
import flash.utils.Timer;
class PrivateClass{}class Group extends EventDispatcher{		// ------- MEMBER -----------------------------------------------		private var _name:String;	private var _length:uint;	private var _lifes:Array;	private var _timer:Timer;		// ------- PUBLIC -----------------------------------------------		/**	 * Constructor.	 * @param name	 */		public function Group( name:String ):void{				_name   = name;		_length = 0;				// ---		_lifes = new Array();				// --- Create Timer. ---		// このタイマーが完了したら安定したとみなす.		_timer = new Timer(10000,1);		_timer.addEventListener(TimerEvent.TIMER_COMPLETE, _onTimerComplete );		_timer.start();			}		public function get name():String{ return _name; }		public function get length():int{ return _length; }		/**	 * 	 * @param ip	 */		public function add( ip:String ):void{		var timer:Timer;		if( !_lifes[ip] ){			timer = new Timer( 100000, 1 );			timer.addEventListener( TimerEvent.TIMER_COMPLETE, function(e:TimerEvent):void{				dispatchEvent( new Event("dead") );			});			_lifes[ip] = timer;			_length++;			// --- restart Timer. ---			if( _timer.running ){				_timer.reset();				_timer.start();			}		}else{			timer = _lifes[ip];		}		timer.reset();		timer.start();	}		/**	 * 	 * @param ip	 */		public function remove( ip:String ):void{		if( _lifes[ip] ){			_lifes[ip] = null;			delete _lifes[ip];			_length--;		}		// --- restart Timer. ---		if( _timer.running ){			_timer.reset();			_timer.start();		}	}		// ------- PRIVATE ----------------------------------------------		/**	 * 安定への Timer を決定するタイマー処理.	 * @param event	 */		private function _onTimerComplete(event:TimerEvent):void{		_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, _onTimerComplete );		dispatchEvent( new Event(Event.CLEAR) );	}	}