/** * * Copyright (c) 2010 - 2013, http://sgmnt.org/ *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * */package org.sgmnt.lib.osc {        import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.TimerEvent;    import flash.net.InterfaceAddress;    import flash.net.NetworkInfo;    import flash.net.NetworkInterface;    import flash.utils.Dictionary;    import flash.utils.Timer;        /**     * OSCSocket 経由での同期処理を司る管理クラスです.	 * このクラスを経由して同期処理が行われます.	 * 	 * このクラスの動作には UDPメッセージの Broadcast 処理が必要となり	 * そのためには OSCBroadcastSocket の初期かも併せて行う必要があります.	 *      * Singleton Class.	 *      * @author  sgmnt.org     * @version 0.1.2     */    public class OSCSyncManager extends EventDispatcher{                //------- CONSTS ----------------------------------------------------------------------- */		        //------- MEMBER ----------------------------------------------------------------------- */                /** Singleton Instance. */        static private var _instance:OSCSyncManager;        		/** OSCSocket での同期処理が有効であるか. */		private var _enabled:Boolean;				/** 同期に利用する OSCBroadcastSocket クラスインスタンス. */		private var _socket:OSCBroadcastSocket;				/** 自身のローカルアドレス. */		private var _localAddress:String;				/** 同期に用いるベースタイム.この値も同期される. */		private var _basetime:Number;		private var _basetimeTimer:Timer;				/** 保持する同期グループ. */		private var _groups:Dictionary;		private var _groupActivateTimerDelay:Number;		private var _groupActivateTimerCount:int;				//------- PUBLIC ----------------------------------------------------------------------- */                /**         * Private Constructor.         */        public function OSCSyncManager( pvtClass:PrivateClass ) {            super();			_enabled = false;			_groups  = new Dictionary();			_groupActivateTimerDelay = 1000;			_groupActivateTimerCount = 10;        }		        /**         * Get Singleton Instance.         * @return         */        static public function getInstance():OSCSyncManager{            if( _instance == null ){                _instance = new OSCSyncManager( new PrivateClass() );            }            return _instance;        }        		/**		 * 初期化処理です.必ず同期を開始する前に、始めに一回実行してください.		 * broadcast の方法などの Manager の基本的な挙動を設定します.		 * 		 * @param configure		 */		public function initialize( configure:OSCSyncManagerConfigure ):void{						// --- Setup Local Address. ---						_localAddress  = configure.localAddress;						// --- Create OSCSocket. ---						_socket = configure.broadcastSocket;			_socket.addEventListener( "/basetime"      , _onBasetimeMessageReceived     );			_socket.addEventListener( OSCSocketEvent.CLOSE, _onSocketClose );			_socket.addEventListener( OSCSocketEvent.ERROR, _onSocketError );						// --- Setup Basetime. ---						_basetime = new Date().time;			_basetimeTimer = new Timer( 10000 );			_basetimeTimer.addEventListener( TimerEvent.TIMER, _onBasetimeUpdateTimer );			_basetimeTimer.start();						// --- Synchronize Basetime. ---						_socket.broadcast( new OSCMessage("/basetime ,d "+basetime) );					}				/**		 * 同期処理を有効化します.		 */		public function enable():void{			if( _enabled == true ){				return;			}			_enabled = true;			dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.ENABLED ) );		}				/**		 * 同期処理を無効化します.		 * 主な利用方法としては自身がホストである際に,一時的に子からの同期処理を停止したい際等に用います.		 */		public function disable():void{			if( _enabled == false ){				return;			}			_enabled = false;			dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.DISABLED ) );		}				/**		 * 内部的に利用している OSCBroadcastSocket への参照です.		 * @return 		 */		public function get socket():OSCBroadcastSocket{			return _socket;		}				/**		 * メッセージのブロードキャストを行います.		 * 送信したメッセージは OSCSyncManager.getInstance().addEventListener( "/address", closure );		 * 経由で受け取る事が出来ます.		 * 		 * @param msg		 */		public function broadcast( msg:OSCPacket ):void{			_socket.broadcast( msg, 100 );		}				// --- Override EventDispatcher Interfaces. ---				/**		 * @param type		 * @param listener		 * @param useCapture		 * @param priority		 * @param useWeakReference		 */		override public function addEventListener( type:String, listener:Function,												   useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false ):void{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :					super.addEventListener( type, listener, useCapture, priority, useWeakReference );					break;				default :					_socket.addEventListener( type, listener, useCapture, priority, useWeakReference );			}		}				/**		 * @param type		 * @param listener		 * @param useCapture		 */		override public function removeEventListener( type:String, listener:Function, useCapture:Boolean = false ):void{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :					super.removeEventListener( type, listener, useCapture );					break;				default :					_socket.removeEventListener( type, listener, useCapture );			}		}				/**		 * @param type		 * @return 		 */		override public function hasEventListener( type:String ):Boolean{			switch( type ){				case OSCSyncManagerEvent.SOCKET_ERROR :				case OSCSyncManagerEvent.ENABLED :				case OSCSyncManagerEvent.DISABLED :					return super.hasEventListener( type );					break;				default :					return _socket.hasEventListener( type );			}		}				/**		 * 同期の基点なる時間を取得します.		 * 		 * この値は原則として同期されている全ての PC と共有されています.		 * そのためこの値をベースに経過時間を加味したアニメーションを実装する事で		 * （理論上）同期のとれたアニメーションを実現する事が出来ます.		 */		public function get basetime():Number{			return _basetime;		}				/**		 * 指定した名称のグループにいくつのクライアントが同期対象として存在するかを取得します.		 * @param name		 * @return 		 */		public function numGroupMember(name:String):int{			return _groups[name] ? _groups[name].numClients : 0;		}				/**         * 指定したグループに対して自分がホストであるか否かを調べます.		 * @param groupName		 * @return 		 */        public function isHost( groupName:String ):Boolean{			return _groups[groupName] && _groups[groupName].hostIP == _localAddress;		}                // --- Control.        		/**		 * グループアクティブ化処理の監視時間の設定		 * @param delay		 * @param repeatCount		 */		public function settingGroupActivateTimer( delay:Number, repeatCount:int ):void{			_groupActivateTimerDelay = delay;			_groupActivateTimerCount = repeatCount;		}		        /**         * 同期グループの生成を行います.         * この関数を複数の PC で実行する事でそれら同士をグループとして関連づけようと試みます.		 * グループ生成の処理は Timer で一定時間ごとに死活監視が行われます.		 *          * @param group グループ名.         */        public function createGroup( process:OSCSyncProcess ):OSCSyncManagerGroup{			// --- OSCSyncProcess からグループ名を取得.			var groupName:String = process.group;			if( _groups[groupName] == null ){				// --- グループが存在していない場合は作成する.				_groups[groupName] = new OSCSyncManagerGroup( this, groupName, 100000.1, _groupActivateTimerDelay, _groupActivateTimerCount );			}			return _groups[groupName];        }		        /**         * grouping の破棄をサーバに要請します.         * @param group グループ名.         */        public function destroyGroup( process:OSCSyncProcess ):void{			_groups[process.group].destroy();			_groups[process.group] = null;			delete _groups[process.group];        }				/**		 * OSCSocket の接続を切断します.		 */				public function close():void{			_socket.close();		}				/**		 * 同期グループの状況を取得します.		 */		public function get status():String{			var str:String = "-------------------------\n";			for( var key:String in _groups ){				str += _groups[key].toString();			}			str += "-------------------------\n";			return str;		}		        //------- PRIVATE ----------------------------------------------------------------------- */				// ===============================================================		// === basetime の設定				/**		 * 自分の basetime を通知し、他のマシンとの整合性を取る.		 * @param event		 */		private function _onBasetimeUpdateTimer(event:TimerEvent):void{			_socket.broadcast( new OSCMessage("/basetime ,d " + basetime), 100 );		}				/**		 * 送られてきた basetime と自分のベースタイムを比べ、より早いベースタイムであった場合そちらにあわせる.		 * @param event		 */		private function _onBasetimeMessageReceived(event:OSCSocketEvent):void{			var time:Number = Number( event.args[0] );			//trace("_onBasetimeMessageReceived", time, _basetime);			if( time < _basetime ){				_basetime = time;			}else if( _basetime < time ){				// --- 自分よりも遅い時刻が送られてきた場合、自分の時間を通知しかえす.				_socket.broadcast( new OSCMessage("/basetime ,d " + basetime) );			}		}				// ===============================================================		// === Socket 関連の処理		        /**         * OSCSocket の接続が閉じられた際に実行されます.         * @param event         */        private function _onSocketClose(event:Event):void{            dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.SOCKET_ERROR ) );        }                /**         * OSCSocket の接続でエラーが発生した際に実行されます.         * エラー発生の旨を通知します.         * @param event         */        private function _onSocketError(event:Event):void{            dispatchEvent( new OSCSyncManagerEvent( OSCSyncManagerEvent.SOCKET_ERROR ) );        }		        //------- PROTECTED ---------------------------------------------------------------------- */                //------- INTERNAL ----------------------------------------------------------------------- */        	}    }class PrivateClass{}