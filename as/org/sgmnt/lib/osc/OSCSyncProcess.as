/** *  * Copyright (c) 2010 - 2013, http://sgmnt.org/ *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * */package org.sgmnt.lib.osc {		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Dictionary;	import flash.utils.Timer;	    /**     * OscSyncManager で管理される処理同期プロセスを定義するためのクラスです.	 * このクラスを使う事で同期処理の定義を簡潔に記述する事が出来ます.	 * 	 * @author  sgmnt.org     * @version 0.2.0     */    public class OSCSyncProcess extends EventDispatcher implements IOSCSyncProcess{                //------- CONSTS ----------------------------------------------------------------------- */				//------- MEMBER ----------------------------------------------------------------------- */				/** 他のマシンではなく同一マシン上で同期を行うために内部的にインスタンスを保持する辞書. */		static private var _INSTANCE_DICTIONARY:Dictionary;		/** プロセス開始時に管理するインスタンスを保持する大元の辞書. */		static private var _PROCESS_TARGET_INSTANCE_LIST:Dictionary;		/** プロセス実行中に処理完了待ちのインスタンスを保持しプロセス終了を判断するために利用する辞書. */		static private var _PROCESS_INSTANCE_LIST:Dictionary;				/** OSCSyncManager */		private var _mngr:OSCSyncManager;				/** 同期グループ. */		private var _group:OSCSyncGroup;				/** 同期のグループ名. */		private var _groupName:String;		/** 同期のキー. */		private var _key:String;		/** 同期通知を行う OSC のアドレス. */		private var _address:String;				/** 同期処理にタイムアウトが存在する場合のタイムアウト用タイマー. */		private var _timeoutTimer:Timer;				/** 同期処理実行時の時刻. */		private var _timestamp:Number;				/** 同期処理が実行中であるか. */		private var _running:Boolean;		/** 同期キャンセル処理が実行中であるか. */		private var _canceling:Boolean;				/** 同期時に受け渡しされる引数. */		private var _args:Array;				/** この同期プロセスに所属するメンバー数. */		private var _groupClients:Array;				/** 現在何番目の同期処理を行っているかのポインタ. */		private var _pointer:int;		/** 同期実行する関数を格納する Vector クラス. */		private var _closureVec:Vector.<OSCSyncProcessClosureLinkedList>;		/** closure 用辞書クラス. */		private var _closureDict:Dictionary;		        //------- PUBLIC ----------------------------------------------------------------------- */                /**         * Constructor.		 * 同期処理の基本情報を定義します.		 * 他のPC上で実行されているインスタンスと gourp で指定したグループの名称が同一であった場合にグループが形成されます.		 * グループ間で複数の同期処理を生成する場合には,必ず別々の key を設定してください.		 * 		 * @param group   同期グループ名.		 * @param key     同期処理を一意に定めるためのユニークキー.		 * @param timeout 同期処理のタイムアウト時間.         */        public function OSCSyncProcess( group:String, key:String, timeout:Number = 0 ) {			            super();						// --- Setup Member Properties. ---						_groupName = group;			_key       = key;			_address   = "/sync/" + _groupName + "/" + _key;						_running   = false;			_canceling = false;			_pointer   = 0;						// --- 処理を実行するポインタと実行される Closure の保持用インスタンスの生成. ---						_closureVec  = new Vector.<OSCSyncProcessClosureLinkedList>();			_closureDict = new Dictionary();						// --- Create timeout timer. If needed. ---						if( 0 < timeout ){				_timeoutTimer = new Timer( timeout, 1 );				_timeoutTimer.addEventListener( TimerEvent.TIMER_COMPLETE, _onTimeoutTimerComplete );			}						// --- Create Static Properties. ----						if( _PROCESS_INSTANCE_LIST == null ){				_PROCESS_INSTANCE_LIST = new Dictionary();			}						if( _PROCESS_TARGET_INSTANCE_LIST == null ){				_PROCESS_TARGET_INSTANCE_LIST = new Dictionary();			}						if( _INSTANCE_DICTIONARY == null ){				_INSTANCE_DICTIONARY = new Dictionary();			}			if( _INSTANCE_DICTIONARY[_address] == null ){				_INSTANCE_DICTIONARY[_address] = new Vector.<OSCSyncProcess>();			}			_INSTANCE_DICTIONARY[_address].push(this);						// --- Setup OSCSyncManager. ---						_mngr = OSCSyncManager.getInstance();			_addEventListeners();						// --- Setup OSCSyncManagerGroup. ---						_group = _mngr.createGroup( this );			_group.addEventListener( OSCSyncGroupEvent.STABLED, _onGroupStabled );			        }				/** 同期グループ. */		public function get group():String{			return _groupName;		}				/** 同期キー */		public function get key():String{			return _key;		}				/** 同期プロセスの名称 (group:key) */		public function get name():String{			return _groupName + ":" + _key;		}				/** 同期開始時刻. */		public function get timestamp():Number{			return _timestamp;		}				// --- Activity Information. ---				/** 同期処理が実行中であるか. */		public function get running():Boolean{			return _running;		}				/**		 * 同期開始を実行可能であるか.		 * @return		 */				public function get canBegin():Boolean{			return _group.canNewProcessBegin && !_running && !_canceling;		}				/**		 * 同期処理プロセスを実行可能であるか.		 */		public function get canExecute():Boolean{			return _running && !_canceling;		}				// --- Host Information. ---				/** 自分がこのグループのホストであるかを調べる. */		public function get isHost():Boolean{			return isLocalLeader && _mngr.isHost( group );		}				/**		 * ローカルグループ内のリーダーであるかを調べる.		 * ローカルグループとは、同一マシン内でインスタンス生成がなされた際に		 * それらのインスタンスをひとまとめにしてローカル同期をとるためのもの.		 * _INSTANCE_DICTIONARYで保管されたリストの一番初めの要素を指す.		 */		public function get isLocalLeader():Boolean{			return _INSTANCE_DICTIONARY != null && _INSTANCE_DICTIONARY[_address] != null && _INSTANCE_DICTIONARY[_address][0] == this;		}				// --- Process Settings. ---				/**		 * 実行する関数を追加します.		 * @param closure		 */		public function addProcess( closure:Function ):void{			// --- 処理実行中は実行の安全のためプロセスの追加は認められません.			if( running ){				throw new Error("Can't addProcess until sync running.");				return;			}			// --- ClosureLinkedList にラップして扱いやすくします.			var c:OSCSyncProcessClosureLinkedList = new OSCSyncProcessClosureLinkedList( _closureVec.length, closure );			_closureDict[closure] = c;			if( 1 < _closureVec.length ){				var tail:OSCSyncProcessClosureLinkedList = _closureVec[_closureVec.length-1];				tail.next = c;				c.prev = tail;			}			_closureVec.push( c );		}				// --- Sync Process. ---				/**		 * 同期処理の開始を行います.		 * 開始の実処理は OSC 経由でメッセージ通知された後,そのハンドラ内で行われる.		 * ホストの場合はその開始メッセージを通知.		 * ホストでない場合は同期開始を求めるメッセージを通知します.		 * @param args		 */		public function begin( ...args ):void{						// --- 既に実行中の場合は Error を throw する. ---			if( running == true ){				throw new Error("OSCSyncProcess [" + name + "] is already running.");				return;			}						_args = new Array().concat( args );						// --- 新規の同期処理開始がグループによって許可されていない場合には実行を許可が通知されるまで遅らせる. ---			if( _group.canNewProcessBegin == false ){				_group.addEventListener( OSCSyncGroupEvent.STABLED, _onNewProcessBeginEnabled );				return;			}						// --- Create OSCMessage for Begin sync. ---						var msg:OSCMessage = new OSCMessage();			if( isHost  == true ){				// --- 自分がホストの場合は同期開始を通知する.				msg.address = _address + "/begin";				msg.addArgument("d", new Date().time);			}else{				// --- 自分がホストでは無い場合は同期開始をホストに通知する.				msg.address = _address + "/begin_";			}			if( _args != null ){				for( var i:int = 0; i < args.length; i++ ){					if( _args[i] is int || _args[i] is uint ){						msg.addArgument( OSCPacket.TYPE_INT32, _args[i] );					}else if( _args[i] is Number ){						msg.addArgument( OSCPacket.TYPE_DOUBLE, _args[i] );					}else if( _args[i] is String ){						msg.addArgument( OSCPacket.TYPE_STRING, _args[i] );					}				}			}			_mngr.broadcast( msg );					}				/**		 * 処理シーケンスの完了通知を行います.		 * ここで指定する引数で指定した関数参照は,現在完了待ちしている処理と同じである必要があります.		 * もし異なった処理の完了を指定した場合,次の begin が開始されるまでそれ以降の同期処理から外されます.		 * @param pointer		 */		public function complete( closure:Function ):void{			//trace( this, "complete", closure );			//trace("OscSyncProcess.complete("+_pointer+")");			if( running == true && _pointer == OSCSyncProcessClosureLinkedList( _closureDict[closure] ).index ){				dispatchEvent( new Event("_complete") );			}else{				dispatchEvent( new Event("_failure") );			}		}				/**		 * 同期処理のキャンセル処理を行います.		 * キャンセルの実処理は OSC 経由でメッセージ通知された後,そのハンドラ内で行われる.		 * 		 * ホストの場合はキャンセル開始メッセージを通知.		 * ホストでない場合はキャンセル開始を求めるメッセージを通知します.		 */		public function cancel():void{			//(this,'cancel');			if( running == true ){				var msg:OSCMessage = new OSCMessage();				if( isHost == true ){					msg.address = _address + "/cancel";				}else{					msg.address = _address + "/cancel_";				}				_mngr.broadcast( msg );			}		}				/**		 * エラー発生を通知します.		 * 通知は処理中のみ受け付けられます.		 */		public function error():void{			//trace(this,'error');			if( running == true ){				var msg:OSCMessage = new OSCMessage();				msg.address = _address + "/error";				_mngr.broadcast( msg );			}		}				/**		 * インスタンスを破棄します.		 * 不要になったインスタンスは必ずこの関数を実行し破棄してください.		 */		public function destroy():void{						//trace("OscSyncProcess.destory()");						_removeEventListeners();			_mngr = null;						_group.removeEventListener( OSCSyncGroupEvent.STABLED, _onGroupStabled );			_group.removeEventListener( OSCSyncGroupEvent.STABLED, _onNewProcessBeginEnabled );			_group.removeEventListener( OSCSyncGroupEvent.REMOVED, _onIPRemoved );			_group = null;						// --- タイムアウトのタイマーが存在する場合停止しておく.						if(_timeoutTimer != null){				_timeoutTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, _onTimeoutTimerComplete );				_timeoutTimer.stop();				_timeoutTimer = null;			}						// --- 自分が抜けるにあたり,必要な処理群から外れる.						var i:int, v:Vector.<OSCSyncProcess>;						v = _INSTANCE_DICTIONARY[_address] as Vector.<OSCSyncProcess>;			for( i = 0; i < v.length; i++ ){				v[i].removeEventListener( "_complete", _onExecuteComplete );				v[i].removeEventListener( "_failure", _onExecuteComplete );				if( v[i] == this ){					v.splice( i--, 1 );				}			}						v = _PROCESS_TARGET_INSTANCE_LIST[_address] as Vector.<OSCSyncProcess>;			for( i = 0; i < v.length; i++ ){				if( v[i] == this ){					v.splice( i--, 1 );				}			}						dispatchEvent( new Event( "_failure" ) );						// --- 破棄された事を通知.						dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.DESTROY ) );					}		        //------- PRIVATE ----------------------------------------------------------------------- */				/**		 * add EventListener.		 */		private function _addEventListeners():void{			_mngr.addEventListener( _address + "/begin"           , _onBegin          );			_mngr.addEventListener( _address + "/begin_"          , _onBeginInquiry   );			_mngr.addEventListener( _address + "/execute"         , _onExecute        );			_mngr.addEventListener( _address + "/complete"        , _onComplete       );			_mngr.addEventListener( _address + "/end"             , _onEnd            );			_mngr.addEventListener( _address + "/cancel"          , _onCancel         );			_mngr.addEventListener( _address + "/cancel_"         , _onCancelInquiry  );			_mngr.addEventListener( _address + "/cancel/start"    , _onCancelStart    );			_mngr.addEventListener( _address + "/cancel/done"        , _onCanceled       );			_mngr.addEventListener( _address + "/cancel/complete" , _onCancelComplete );			_mngr.addEventListener( _address + "/error"           , _onError          );		}				/**		 * remove EventListener.		 */				private function _removeEventListeners():void{			_mngr.removeEventListener( _address + "/begin"           , _onBegin          );			_mngr.removeEventListener( _address + "/begin_"          , _onBeginInquiry   );			_mngr.removeEventListener( _address + "/execute"         , _onExecute        );			_mngr.removeEventListener( _address + "/complete"        , _onComplete       );			_mngr.removeEventListener( _address + "/end"             , _onEnd            );			_mngr.removeEventListener( _address + "/cancel"          , _onCancel         );			_mngr.removeEventListener( _address + "/cancel_"         , _onCancelInquiry  );			_mngr.removeEventListener( _address + "/cancel/start"    , _onCancelStart    );			_mngr.removeEventListener( _address + "/cancel/done"        , _onCanceled       );			_mngr.removeEventListener( _address + "/cancel/complete" , _onCancelComplete );			_mngr.removeEventListener( _address + "/error"           , _onError          );		}				/**		 * タイムアウト発生時の処理.		 * キャンセル処理を行います.		 * @param event		 */		private function _onTimeoutTimerComplete(event:TimerEvent):void{			//trace(this,'_onTimeoutTimerComplete');			cancel();		}				/**		 * グループへの参加が完了した際の処理.		 * @param event		 */		private function _onGroupStabled(event:OSCSyncGroupEvent):void{			//trace(this,'_onGroupStabled');			dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.AVAILABLE ) );		}				// ==================================================		// for Sync Process.		// ==================================================				/**		 * 同期グループが安定しておらず,新規プロセスの受付を許可していなかった場合に		 * 実行をグループの許可がおりるタイミングまで遅らせた場合のハンドラ.		 * 自身がホストであった場合に改めて begin を実行します.		 * @param event		 */		private function _onNewProcessBeginEnabled(event:OSCSyncGroupEvent):void{			//trace( this, "_onNewProcessBeginEnabled" );			_group.removeEventListener( OSCSyncGroupEvent.STABLED, _onNewProcessBeginEnabled );			if( isHost ){				begin.apply(null, _args);			}		}				/**		 * 同期開始の申請が来た際の処理.		 * 		 * 同期開始が認められているのは親として定義されたインスタンスのみであり		 * 子として定義されたインスタンスに関しては親要素に対して実行を申請する事になる.		 * そのメッセージを受け取るのがこの関数.		 * 		 * If isHost and not running yet. begin sync process.		 * 		 * @param event		 */		private function _onBeginInquiry(event:OSCSocketEvent):void{			//trace( this, "_onBeginInquiry" );			if( isHost && !running ){				begin.apply(null,event.args);			}		}				/**		 * 同期処理の開始が通知された際の処理.		 * 		 * 同期処理はすべてここから始まる.この関数が実行されたタイミング初め running プロパティが true となる.		 * running が true となっていない状況, 例えば何らかの同期プロセスが開始されたタイミング以降に		 * 遅れて active になったインスタンスは, running を true に出来ていないためその回の同期は行われない事となる.		 * 		 * TODO 同期待ちだったインスタンスがあるかどうかを保持して、もう一度やり直すべきか等を検討出来る様にした方が良さそう、		 * 		 * @param event		 */				private function _onBegin(event:OSCSocketEvent):void{						//trace( this, "_onBegin" );						// --- If begin is not available. return immediately						if( canBegin == false ){				return;			}						var i:int;						// --- Init Properties.						_running      = true;			_pointer      = 0;			_timestamp    = Number( event.args[0] );			_groupClients = _group.createClientIPArray();						// --- Setup OSCMessage arguments.						_args = new Array();			for( i = 1; i < event.args.length; i++ ){				_args.push( event.args[i] );			}						// --- ローカル内の親が代表して OSC を送信するために.			// --- インスタンスの一覧を保持し,内部のコンプリートを監視する.						if( isLocalLeader == true ){				var v:Vector.<OSCSyncProcess>  = _INSTANCE_DICTIONARY[_address],					v2:Vector.<OSCSyncProcess> = new Vector.<OSCSyncProcess>(),					v3:Vector.<OSCSyncProcess> = new Vector.<OSCSyncProcess>();				for( i = 0; i < v.length; i++ ){					v[i].addEventListener( "_complete", _onExecuteComplete );					v[i].addEventListener( "_failure", _onExecuteComplete );					v2.push(v[i]);					v3.push(v[i]);				}				_PROCESS_TARGET_INSTANCE_LIST[_address] = v2;				_PROCESS_INSTANCE_LIST[_address]        = v3;			}						// --- If timeout timer exists. Start timer.						if(_timeoutTimer != null ){				_timeoutTimer.reset();				_timeoutTimer.start();			}						// --- Dispatch Begin Event.						dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.BEGIN ) );						// --- addEventListener for Sync Conditioning.						_group._numRunningProcess++;			_group.addEventListener( OSCSyncGroupEvent.REMOVED, _onIPRemoved );						// --- If this instance is Host. Broadcast "/execute" OSC message.						if( isHost == true ){				var msg:OSCMessage = new OSCMessage();				msg.address = _address + "/execute";				msg.addArgument( "i", _pointer );				msg.addArgument( "d", timestamp);				_mngr.broadcast( msg );			}					}				/**		 * 実行を通知された際の処理.		 * @param event		 */		private function _onExecute(event:OSCSocketEvent):void{						if( canExecute == false ){				// 実行不可能状態の場合.無条件で完了とする.				dispatchEvent( new Event("_failure") );				return;			}						// --- complete を受け取った数.			// --- 次のプロセスに進むかを判断するのに使う.						_pointer       = event.args[0];			_timestamp     = Number(event.args[1]);						// --- Execute Closure.						_closureVec[_pointer].closure(_args);						// Timeout の Timer が設定されている場合は処理が実行されたのでリセットする.			if( _timeoutTimer != null ){				_timeoutTimer.reset();				_timeoutTimer.start();			}					}				/**		 * 処理完了時の処理.		 * 内部にインスタンスが複数存在した場合に対応するための処理.		 * 内部的に作成された OscSyncProcess の数に応じて、処理内容を決定する.		 * 		 * ローカル内の親が代表して OSC を送信するために.		 * インスタンスの一覧を保持し,内部のコンプリートを監視する.		 * @param	event		 */		private function _onExecuteComplete(event:Event):void{						//trace( this, "_onExecuteComplete" );						if( isLocalLeader == true ){								var i:int,				v:Vector.<OSCSyncProcess>,				v2:Vector.<OSCSyncProcess>;								// --- _failure であった場合				// --- _PROCESS_TARGET_INSTANCE_LIST に保持しているインスタンスを照合しこれ以降の処理対象から削除する.				if( event.type == "_failure" ){					v = _PROCESS_TARGET_INSTANCE_LIST[_address];					for( i = 0; i < v.length; i++ ){						if( v[i] == event.target ){							v[i].removeEventListener( "_complete", _onExecuteComplete );							v[i].removeEventListener( "_failure", _onExecuteComplete );							v.splice(i--,1);						}					}				}								// --- 保持しているインスタンスを照合し、存在すれば完了とみなす.				v = _PROCESS_INSTANCE_LIST[_address];				for( i = 0; i < v.length; i++ ){					if( v[i] == event.target ){						v[i].removeEventListener( "_complete", _onExecuteComplete );						v[i].removeEventListener( "_failure", _onExecuteComplete );						v.splice(i--,1);					}				}								// --- 監視すべきインスタンスが、リストからなくなった場合に完了を通知する.				if( v.length == 0 ){										v  = _PROCESS_TARGET_INSTANCE_LIST[_address];					v2 = new Vector.<OSCSyncProcess>();					for( i = 0; i < v.length; i++ ){						v[i].addEventListener( "_complete", _onExecuteComplete );						v[i].addEventListener( "_failure", _onExecuteComplete );						v[i].dispatchEvent(	new OSCSyncProcessEvent( OSCSyncProcessEvent.COMPLETE ) );						v2.push(v[i]);					}					_PROCESS_INSTANCE_LIST[_address] = v2;										var msg:OSCMessage = new OSCMessage();					msg.address = _address + "/complete";					msg.addArgument("i", _pointer );					_mngr.broadcast( msg );									}							}					}				/**		 * 処理完了時の処理.		 * @param event		 */		private function _onComplete(event:OSCSocketEvent):void{			trace( this, "_onComplete" );			if( _groupClients != null && _pointer == int(event.args[0]) ){				trace( _groupClients );				trace( event.srcAddress );				trace('===');				for( var i:int = 0; i < _groupClients.length; i++ ){					if( _groupClients[i] == event.srcAddress ){						_groupClients.splice(i--,1);					}				}				trace( _groupClients );				trace('================');				if( isHost == true && _groupClients.length <= 0 ){					var msg:OSCMessage = new OSCMessage();					if( ++_pointer == _closureVec.length ){						msg.address = _address + "/end";					}else{						msg.address = _address + "/execute";						msg.addArgument( "i", _pointer );						msg.addArgument( "d", timestamp);					}					_mngr.broadcast( msg );				}			}		}				/**		 * 同期処理中にグループのリストからIPの削除があった場合の処理.		 * 実行完了待ちのIPのリストに削除されたIPが存在するかを調べ,存在すれば完了待ちから外す.		 * @param event		 */		private function _onIPRemoved(event:OSCSyncGroupEvent):void{			if( _running ){				var exists:Boolean;				var list:Array = _group.createClientIPArray();				for( var i:int = 0; i < _groupClients.length; i++ ){					exists = false;					for( var j:int = 0; j < list.length; j++ ){						if( _groupClients[i] == list[j] ){							exists = true;							continue;						}					}					if( exists == false ){						_groupClients.splice(i--,1);					}				}				if( isHost == true && _groupClients.length <= 0 ){					var msg:OSCMessage = new OSCMessage();					if( ++_pointer == _closureVec.length ){						msg.address = _address + "/end";					}else{						msg.address = _address + "/execute";						msg.addArgument( "i", _pointer );						msg.addArgument( "d", timestamp);					}					_mngr.broadcast( msg );				}			}		}				/**		 * 完了を通知された際の処理.		 * @param event		 */		private function _onEnd(event:OSCSocketEvent):void{						//trace(this,'_onEnd');			_running = false;						_group._numRunningProcess--;			_group.removeEventListener( OSCSyncGroupEvent.REMOVED, _onIPRemoved );						if( _timeoutTimer != null ){				_timeoutTimer.stop();				_timeoutTimer.reset();			}						dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.END ) );					}				// ==================================================		// for Cancel Process.		// ==================================================				/**		 * キャンセル処理をクライアントからホストに対して要請した際の処理.		 * ホストであればキャンセルを行う.		 * @param event		 */		private function _onCancelInquiry(event:OSCSocketEvent):void{			//trace(this,'_onCancelInquiry');			if( isHost == true && running == true ){				var msg:OSCMessage = new OSCMessage();				msg.address = _address+"/cancel";				_mngr.broadcast( msg );			}		}				/**		 * キャンセル処理を通知された際の処理.		 * Host であった場合はキャンセルプロセスを開始します.		 * @param event		 */		private function _onCancel(event:OSCSocketEvent):void{			//trace(this,'_onCancel');			_running      = false;			_canceling    = true;			_groupClients = _group.createClientIPArray();			if( isHost == true ){				var msg:OSCMessage = new OSCMessage();				msg.address = _address+"/cancel/start";				_mngr.broadcast( msg );			}		}				/**		 * キャンセル処理の開始が通達された際の処理.		 * キャンセルを行います.		 * @param event		 */		private function _onCancelStart(event:OSCSocketEvent):void{						//(this,'_onCancelStart');						var i:int, v:Vector.<OSCSyncProcess>;						// --- Cancel watching events from all process instances if exists.						v = _PROCESS_INSTANCE_LIST[_address];			if( v != null && 0 < v.length ){				for( i = 0; i < v.length; i++ ){					v[i].removeEventListener( "_complete", _onExecuteComplete );					v[i].removeEventListener( "_failure", _onExecuteComplete );				}			}						// --- Stop Timeout Timer If _timeoutTimer exists. ---						if( _timeoutTimer != null ){				_timeoutTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, _onTimeoutTimerComplete );				_timeoutTimer.stop();			}						// --- Remove from target instance list. ---						_PROCESS_TARGET_INSTANCE_LIST[_address] = null;			delete _PROCESS_TARGET_INSTANCE_LIST[_address];						_PROCESS_INSTANCE_LIST[_address] = null;			delete _PROCESS_INSTANCE_LIST[_address];						// --- Send OSC Message. ---						var msg:OSCMessage = new OSCMessage();			msg.address = _address+"/cancel/done";			_mngr.broadcast( msg );					}				/**		 * クライアントからのキャンセル完了通知を取得し.		 * 全クライアントがキャンセルされたタイミングでメッセージを通達する.		 * @param event		 */				private function _onCanceled(event:OSCSocketEvent):void{			//trace(this,'_onCanceled');			if( _groupClients != null ){				for( var i:int = 0; i < _groupClients.length; i++ ){					if( _groupClients[i] == event.srcAddress ){						_groupClients.splice(i--,1);					}				}				if( isHost && _groupClients.length <= 0 ){					var msg:OSCMessage = new OSCMessage();					msg.address = _address+"/cancel/complete";					_mngr.broadcast( msg );				}			}		}				/**		 * 全てのキャンセル処理が完了した際の処理.		 * CANCEL イベントを通知します.		 * @param event		 */		private function _onCancelComplete(event:OSCSocketEvent):void{			//trace(this,'_onCancelComplete');			_canceling = false;			_group._numRunningProcess--;			_group.addEventListener( OSCSyncGroupEvent.REMOVED, _onIPRemoved );			dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.CANCEL ) );		}				// ==================================================		// for Error Process.		// ==================================================				private function _onError(event:OSCSocketEvent):void{			//trace(this,'_onError');			//trace("OscSyncProcess.error()");			dispatchEvent( new OSCSyncProcessEvent( OSCSyncProcessEvent.ERROR ) );		}				//------- PROTECTED ---------------------------------------------------------------------- */                //------- INTERNAL ----------------------------------------------------------------------- */		    }	}class PrivateClass{}